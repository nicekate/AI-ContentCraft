<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="AI ContentCraft - å¼ºå¤§çš„å†…å®¹åˆ›ä½œå·¥å…·ï¼Œå…·å¤‡æ•…äº‹ç”Ÿæˆã€æ–‡æœ¬è½¬è¯­éŸ³å’Œå›¾åƒç”ŸæˆåŠŸèƒ½">
    <meta name="keywords" content="AI, å†…å®¹åˆ›ä½œ, æ•…äº‹ç”Ÿæˆ, æ–‡æœ¬è½¬è¯­éŸ³, TTS, æ’­å®¢, å›¾åƒç”Ÿæˆ">
    <meta name="author" content="AI ContentCraft">

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ¨</text></svg>">

    <title>AI ContentCraft - æ™ºèƒ½å†…å®¹åˆ›ä½œå¹³å°</title>

    <!-- External Stylesheets -->
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="modern-styles.css">

    <!-- Preconnect to external domains for performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>


</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="sr-only">Skip to main content</a>

    <div class="container">
        <!-- Header with navigation -->
        <header role="banner">
            <nav class="nav-bar" role="navigation" aria-label="ä¸»å¯¼èˆª">
                <button class="nav-button active" onclick="switchPage('story')" aria-pressed="true" aria-describedby="story-desc">
                    <span>ğŸ“–</span> æ•…äº‹ç”Ÿæˆå™¨
                </button>
                <button class="nav-button" onclick="switchPage('simple')" aria-pressed="false" aria-describedby="simple-desc">
                    <span>ğŸ—£ï¸</span> ç®€å•è¯­éŸ³åˆæˆ
                </button>
                <button class="nav-button" onclick="switchPage('multi')" aria-pressed="false" aria-describedby="multi-desc">
                    <span>ğŸ­</span> å¤šå£°éŸ³è¯­éŸ³åˆæˆ
                </button>
                <button class="nav-button" onclick="switchPage('podcast')" aria-pressed="false" aria-describedby="podcast-desc">
                    <span>ğŸ™ï¸</span> æ’­å®¢ç”Ÿæˆå™¨
                </button>
            </nav>

            <!-- Hidden descriptions for screen readers -->
            <div class="sr-only">
                <div id="story-desc">ç”Ÿæˆæ•…äº‹å¹¶è½¬æ¢ä¸ºå¸¦å›¾åƒçš„è„šæœ¬</div>
                <div id="simple-desc">ä½¿ç”¨å•ä¸€å£°éŸ³å°†æ–‡æœ¬è½¬æ¢ä¸ºè¯­éŸ³</div>
                <div id="multi-desc">ä½¿ç”¨ä¸åŒè¯´è¯è€…åˆ›å»ºå¤šå£°éŸ³éŸ³é¢‘</div>
                <div id="podcast-desc">ç”Ÿæˆå¤šä¸»æŒäººæ’­å®¢å†…å®¹</div>
            </div>
        </header>

        <!-- Main content area -->
        <main id="main-content" role="main">

            <!-- Story Generator Page -->
            <section id="storyPage" class="page active" aria-labelledby="story-title">
                <div class="story-page-layout">
                    <!-- Left Side: Instructions Panel -->
                    <div class="instructions-panel">
                        <div class="instructions-header">
                            <h2>ğŸ“‹ æ“ä½œæŒ‡å—</h2>
                            <p class="instructions-subtitle">æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤åˆ›å»ºæ‚¨çš„æ•…äº‹</p>
                        </div>

                        <div class="instruction-steps">
                            <div class="instruction-step">
                                <div class="step-number">1</div>
                                <div class="step-content">
                                    <h3>è¾“å…¥æ•…äº‹ä¸»é¢˜</h3>
                                    <p>åœ¨å³ä¾§è¾“å…¥æ¡†ä¸­æè¿°æ‚¨æƒ³è¦çš„æ•…äº‹ä¸»é¢˜ï¼Œä¾‹å¦‚"å¤ªç©ºå†’é™©"ã€"é­”æ³•æ£®æ—"ç­‰</p>
                                </div>
                                <div class="step-arrow">â†’</div>
                            </div>

                            <div class="instruction-step">
                                <div class="step-number">2</div>
                                <div class="step-content">
                                    <h3>é€‰æ‹©è¯­è¨€</h3>
                                    <p>é€‰æ‹©æ‚¨å¸Œæœ›ç”Ÿæˆæ•…äº‹çš„è¯­è¨€ï¼šä¸­æ–‡æˆ–è‹±æ–‡</p>
                                </div>
                                <div class="step-arrow">â†’</div>
                            </div>

                            <div class="instruction-step">
                                <div class="step-number">3</div>
                                <div class="step-content">
                                    <h3>ç”Ÿæˆæ•…äº‹</h3>
                                    <p>ç‚¹å‡»"ç”Ÿæˆæ•…äº‹"æŒ‰é’®ï¼ŒAIå°†ä¸ºæ‚¨åˆ›ä½œä¸€ä¸ªç²¾å½©çš„æ•…äº‹</p>
                                </div>
                                <div class="step-arrow">â†’</div>
                            </div>

                            <div class="instruction-step">
                                <div class="step-number">4</div>
                                <div class="step-content">
                                    <h3>è½¬æ¢ä¸ºè„šæœ¬</h3>
                                    <p>æ•…äº‹ç”Ÿæˆåï¼Œå¯ä»¥å°†å…¶è½¬æ¢ä¸ºåŒ…å«å¯¹è¯å’Œæ—ç™½çš„è„šæœ¬æ ¼å¼</p>
                                </div>
                                <div class="step-arrow">â†’</div>
                            </div>

                            <div class="instruction-step">
                                <div class="step-number">5</div>
                                <div class="step-content">
                                    <h3>ç”ŸæˆéŸ³é¢‘å’Œå›¾ç‰‡</h3>
                                    <p>ä¸ºæ¯ä¸ªè„šæœ¬æ®µè½ç”Ÿæˆè¯­éŸ³å’Œé…å›¾ï¼Œåˆ›å»ºå®Œæ•´çš„å¤šåª’ä½“æ•…äº‹</p>
                                </div>
                            </div>
                        </div>

                        <div class="tips-section">
                            <h3>ğŸ’¡ å°è´´å£«</h3>
                            <ul class="tips-list">
                                <li>ä¸»é¢˜æè¿°è¶Šè¯¦ç»†ï¼Œç”Ÿæˆçš„æ•…äº‹è¶Šç²¾å½©</li>
                                <li>å¯ä»¥æŒ‡å®šæ•…äº‹ç±»å‹ï¼Œå¦‚"ç§‘å¹»"ã€"ç«¥è¯"ã€"æ‚¬ç–‘"ç­‰</li>
                                <li>ç”Ÿæˆåå¯ä»¥ç¼–è¾‘æ•…äº‹å†…å®¹ï¼Œè®©å®ƒæ›´ç¬¦åˆæ‚¨çš„éœ€æ±‚</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Right Side: Story Generation Section -->
                    <div class="story-generation-panel">
                        <div class="story-container">
                            <h1 id="story-title">âœ¨ æ•…äº‹ç”Ÿæˆ</h1>
                            <div class="form-group">
                                <label for="themeInput" class="sr-only">æ•…äº‹ä¸»é¢˜</label>
                                <input
                                    type="text"
                                    id="themeInput"
                                    class="theme-input"
                                    placeholder="è¾“å…¥æ‚¨çš„æ•…äº‹ä¸»é¢˜ï¼ˆä¾‹å¦‚ï¼š'å¤ªç©ºä¸­çš„ç¥å¥‡å†’é™©'ï¼‰..."
                                    aria-describedby="theme-help"
                                    autocomplete="off"
                                >
                                <div id="theme-help" class="sr-only">ä¸ºæ‚¨çš„æ•…äº‹è¾“å…¥ä¸»é¢˜æˆ–è¯é¢˜</div>
                            </div>

                            <!-- Language Selection for Story -->
                            <div class="form-group">
                                <label class="language-label">é€‰æ‹©æ•…äº‹è¯­è¨€ / Choose Story Language:</label>
                                <div class="language-options">
                                    <label class="radio-option">
                                        <input type="radio" name="storyLanguage" value="chinese" checked>
                                        <span class="radio-text">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</span>
                                    </label>
                                    <label class="radio-option">
                                        <input type="radio" name="storyLanguage" value="english">
                                        <span class="radio-text">ğŸ‡ºğŸ‡¸ English</span>
                                    </label>
                                </div>
                            </div>
                            <div class="button-container">
                                <button onclick="generateStory()" id="generateStoryBtn" class="primary-btn" aria-describedby="generate-help">
                                    <span class="spinner" id="storySpinner"></span>
                                    <span id="generateStoryText">ğŸ¯ ç”Ÿæˆæ•…äº‹</span>
                                </button>
                            </div>
                            <div id="generate-help" class="sr-only">ç‚¹å‡»æ ¹æ®æ‚¨çš„ä¸»é¢˜ç”Ÿæˆæ•…äº‹</div>

                            <div class="form-group">
                                <label for="storyText" class="sr-only">ç”Ÿæˆçš„æ•…äº‹å†…å®¹</label>
                                <textarea
                                    id="storyText"
                                    class="text-input"
                                    placeholder="æ‚¨ç”Ÿæˆçš„æ•…äº‹å°†åœ¨è¿™é‡Œæ˜¾ç¤º..."
                                    aria-describedby="story-help"
                                    readonly
                                ></textarea>
                                <div id="story-help" class="sr-only">ç”Ÿæˆçš„æ•…äº‹å†…å®¹å°†åœ¨æ­¤å¤„æ˜¾ç¤º</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Script Conversion Section -->
                <div class="script-container">
                    <h2 id="script-title">ğŸ¬ è„šæœ¬è½¬æ¢</h2>
                    <div class="script-buttons">
                        <button onclick="generateScript()" id="convertToScript" class="btn primary convert-script" aria-describedby="convert-help">
                            <span class="spinner" id="convertSpinner"></span>
                            <span id="convertText">ğŸ“ è½¬æ¢ä¸ºè„šæœ¬</span>
                        </button>
                        <div class="button-row">
                            <button onclick="generateStoryAudio()" id="generateStoryAudioBtn" class="btn secondary hidden" aria-describedby="audio-help">
                                <span class="spinner" id="audioSpinner"></span>
                                <span id="storyBtnText">ğŸµ ç”ŸæˆéŸ³é¢‘</span>
                            </button>
                            <button onclick="downloadAllImages()" id="downloadImages" class="btn secondary hidden" aria-describedby="download-help">
                                <span>ğŸ“¥</span> ä¸‹è½½æ‰€æœ‰å›¾ç‰‡
                            </button>
                        </div>
                    </div>

                    <!-- Hidden help text for screen readers -->
                    <div class="sr-only">
                        <div id="convert-help">å°†æ‚¨çš„æ•…äº‹è½¬æ¢ä¸ºåŒ…å«å¯¹è¯å’Œæ—ç™½çš„è„šæœ¬æ ¼å¼</div>
                        <div id="audio-help">ä»è„šæœ¬éƒ¨åˆ†ç”ŸæˆéŸ³é¢‘</div>
                        <div id="download-help">å°†æ‰€æœ‰ç”Ÿæˆçš„å›¾ç‰‡ä¸‹è½½ä¸ºzipæ–‡ä»¶</div>
                    </div>

                    <div id="scriptSections" role="region" aria-label="è„šæœ¬éƒ¨åˆ†">
                        <!-- Script sections will be dynamically generated here -->
                    </div>

                    <div class="progress-container hidden" id="storyProgressContainer" role="status" aria-live="polite">
                        <div class="progress-text">
                            æ­£åœ¨ç”Ÿæˆï¼š<span id="storyCurrentProgress">0</span>/<span id="storyTotalSections">0</span>
                        </div>
                        <div class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                            <div class="progress" id="storyProgress"></div>
                        </div>
                    </div>

                    <div class="audio-container">
                        <label for="storyAudioPlayer" class="sr-only">ç”Ÿæˆçš„æ•…äº‹éŸ³é¢‘</label>
                        <audio id="storyAudioPlayer" controls preload="none" aria-describedby="audio-player-help">
                            <source src="" type="audio/mp3">
                            æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
                        </audio>
                        <div id="audio-player-help" class="sr-only">ç”Ÿæˆæ•…äº‹çš„éŸ³é¢‘æ’­æ”¾å™¨</div>
                    </div>
                </div>
            </section>

            <!-- Simple TTS Page -->
            <section id="simplePage" class="page" aria-labelledby="simple-title">
                <div class="simple-tts-container">
                    <h1 id="simple-title">ğŸ—£ï¸ ç®€å•æ–‡æœ¬è½¬è¯­éŸ³</h1>

                    <div class="form-group">
                        <label for="simpleTtsText" class="sr-only">è¦è½¬æ¢ä¸ºè¯­éŸ³çš„æ–‡æœ¬</label>
                        <textarea
                            id="simpleTtsText"
                            class="text-input"
                            placeholder="è¾“å…¥æ‚¨æƒ³è¦è½¬æ¢ä¸ºè¯­éŸ³çš„æ–‡æœ¬..."
                            aria-describedby="simple-text-help"
                            style="min-height: 150px;"
                        ></textarea>
                        <div id="simple-text-help" class="sr-only">è¾“å…¥ä»»ä½•æ–‡æœ¬ä»¥å°†å…¶è½¬æ¢ä¸ºè¯­éŸ³</div>
                    </div>

                    <div class="voice-select-container">
                        <label for="simpleTtsVoice" class="form-label">ğŸ­ é€‰æ‹©å£°éŸ³ï¼š</label>
                        <select id="simpleTtsVoice" class="voice-select" aria-describedby="voice-help">
                            <option value="">æ­£åœ¨åŠ è½½å£°éŸ³...</option>
                        </select>
                        <div id="voice-help" class="sr-only">ä¸ºæ–‡æœ¬è½¬è¯­éŸ³è½¬æ¢é€‰æ‹©å£°éŸ³</div>
                    </div>

                    <div class="button-container">
                        <button onclick="generateSimpleTTS()" id="simpleTtsBtn" class="primary-btn" aria-describedby="simple-generate-help">
                            <span class="spinner" id="simpleTtsSpinner"></span>
                            <span id="simpleTtsButtonText">ğŸµ ç”ŸæˆéŸ³é¢‘</span>
                        </button>
                    </div>
                    <div id="simple-generate-help" class="sr-only">ä»è¾“å…¥çš„æ–‡æœ¬ç”ŸæˆéŸ³é¢‘</div>

                    <div class="audio-container">
                        <label for="simpleTtsPlayer" class="sr-only">ç”Ÿæˆçš„éŸ³é¢‘</label>
                        <audio id="simpleTtsPlayer" controls preload="none" aria-describedby="simple-audio-help">
                            <source src="" type="audio/mp3">
                            æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
                        </audio>
                        <div id="simple-audio-help" class="sr-only">ç”Ÿæˆè¯­éŸ³çš„éŸ³é¢‘æ’­æ”¾å™¨</div>
                    </div>
                </div>
            </section>

            <!-- Multi-Voice TTS Page -->
            <section id="multiPage" class="page" aria-labelledby="multi-title">
                <div class="multi-tts-container">
                    <h1 id="multi-title">ğŸ­ å¤šå£°éŸ³æ–‡æœ¬è½¬è¯­éŸ³</h1>

                    <div class="tabs-container">
                        <div class="tabs" role="tablist" aria-label="æ–‡æœ¬éƒ¨åˆ†">
                            <button class="tab-btn active" onclick="switchTab(0)" role="tab" aria-selected="true" aria-controls="panel-0" id="tab-0">
                                ğŸ“ éƒ¨åˆ† 1
                            </button>
                            <button class="tab-btn" onclick="switchTab(1)" role="tab" aria-selected="false" aria-controls="panel-1" id="tab-1">
                                ğŸ“ éƒ¨åˆ† 2
                            </button>
                            <button class="tab-btn add-tab" onclick="addNewTab()" aria-label="æ·»åŠ æ–°éƒ¨åˆ†">
                                â•
                            </button>
                        </div>

                        <div class="tab-panels">
                            <div class="tab-panel active" role="tabpanel" aria-labelledby="tab-0" id="panel-0">
                                <div class="form-group">
                                    <label for="text-0" class="sr-only">éƒ¨åˆ†1çš„æ–‡æœ¬</label>
                                    <textarea
                                        id="text-0"
                                        class="text-input"
                                        placeholder="è¾“å…¥æ­¤éƒ¨åˆ†çš„æ–‡æœ¬..."
                                        aria-describedby="text-help-0"
                                    ></textarea>
                                    <div id="text-help-0" class="sr-only">è¾“å…¥è¦ç”±æ‰€é€‰å£°éŸ³æœ—è¯»çš„æ–‡æœ¬</div>
                                </div>
                                <div class="voice-select-container">
                                    <label for="voice-0" class="form-label">ğŸ­ å£°éŸ³ï¼š</label>
                                    <select id="voice-0" class="voice-select" aria-describedby="voice-help-0">
                                        <option value="">æ­£åœ¨åŠ è½½å£°éŸ³...</option>
                                    </select>
                                    <div id="voice-help-0" class="sr-only">ä¸ºæ­¤éƒ¨åˆ†é€‰æ‹©å£°éŸ³</div>
                                </div>
                            </div>

                            <div class="tab-panel" role="tabpanel" aria-labelledby="tab-1" id="panel-1">
                                <div class="form-group">
                                    <label for="text-1" class="sr-only">éƒ¨åˆ†2çš„æ–‡æœ¬</label>
                                    <textarea
                                        id="text-1"
                                        class="text-input"
                                        placeholder="è¾“å…¥æ­¤éƒ¨åˆ†çš„æ–‡æœ¬..."
                                        aria-describedby="text-help-1"
                                    ></textarea>
                                    <div id="text-help-1" class="sr-only">è¾“å…¥è¦ç”±æ‰€é€‰å£°éŸ³æœ—è¯»çš„æ–‡æœ¬</div>
                                </div>
                                <div class="voice-select-container">
                                    <label for="voice-1" class="form-label">ğŸ­ å£°éŸ³ï¼š</label>
                                    <select id="voice-1" class="voice-select" aria-describedby="voice-help-1">
                                        <option value="">æ­£åœ¨åŠ è½½å£°éŸ³...</option>
                                    </select>
                                    <div id="voice-help-1" class="sr-only">ä¸ºæ­¤éƒ¨åˆ†é€‰æ‹©å£°éŸ³</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="button-container">
                        <button onclick="generateAllAudio()" id="generateBtn" class="primary-btn" aria-describedby="generate-all-help">
                            <span class="spinner" id="spinner"></span>
                            <span id="btnText">ğŸµ ç”Ÿæˆæ‰€æœ‰éŸ³é¢‘</span>
                        </button>
                        <button onclick="exportMergedAudio()" id="exportBtn" class="action-btn" aria-describedby="export-help">
                            <span>ğŸ“¥</span> å¯¼å‡ºåˆå¹¶éŸ³é¢‘
                        </button>
                    </div>

                    <!-- Hidden help text -->
                    <div class="sr-only">
                        <div id="generate-all-help">ä¸ºæ‰€æœ‰éƒ¨åˆ†ç”ŸæˆéŸ³é¢‘å¹¶å°†å®ƒä»¬åˆå¹¶åœ¨ä¸€èµ·</div>
                        <div id="export-help">ä¸‹è½½åˆå¹¶çš„éŸ³é¢‘æ–‡ä»¶</div>
                    </div>

                    <div class="progress-container hidden" id="progressContainer" role="status" aria-live="polite">
                        <div class="progress-text">æ­£åœ¨å¤„ç†éƒ¨åˆ†...</div>
                        <div class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                            <div class="progress" id="progress"></div>
                        </div>
                    </div>

                    <div class="audio-container">
                        <label for="multiAudioPlayer" class="sr-only">ç”Ÿæˆçš„åˆå¹¶éŸ³é¢‘</label>
                        <audio id="multiAudioPlayer" controls preload="none" aria-describedby="multi-audio-help">
                            <source src="" type="audio/mp3">
                            æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
                        </audio>
                        <div id="multi-audio-help" class="sr-only">åˆå¹¶å¤šå£°éŸ³éŸ³é¢‘çš„éŸ³é¢‘æ’­æ”¾å™¨</div>
                    </div>

                    <div class="history-container" id="historyContainer" role="region" aria-label="ç”Ÿæˆå†å²">
                        <!-- History items will be dynamically added here -->
                    </div>
                </div>
            </section>

            <!-- Podcast Generator Page -->
            <section id="podcastPage" class="page" aria-labelledby="podcast-title">
                <div class="podcast-container">
                    <h1 id="podcast-title">ğŸ™ï¸ æ’­å®¢ç”Ÿæˆå™¨</h1>

                    <!-- Topic Input Section -->
                    <div class="topic-section">
                        <div class="form-group">
                            <label for="podcastTopic" class="form-label">ğŸ“ æ’­å®¢ä¸»é¢˜æˆ–å†…å®¹ï¼š</label>
                            <textarea
                                id="podcastTopic"
                                class="topic-input"
                                placeholder="åœ¨æ­¤è¾“å…¥æ‚¨çš„æ’­å®¢ä¸»é¢˜ã€å¤§çº²æˆ–å†…å®¹ã€‚å¯ä»¥å°½å¯èƒ½è¯¦ç»†..."
                                rows="6"
                                aria-describedby="topic-help"
                            ></textarea>
                            <div id="topic-help" class="sr-only">è¾“å…¥æ‚¨æ’­å®¢çš„ä¸»é¢˜æˆ–å†…å®¹</div>
                        </div>

                        <!-- Language Selection for Podcast -->
                        <div class="form-group">
                            <label class="language-label">é€‰æ‹©æ’­å®¢è¯­è¨€ / Choose Podcast Language:</label>
                            <div class="language-options">
                                <label class="radio-option">
                                    <input type="radio" name="podcastLanguage" value="chinese" checked>
                                    <span class="radio-text">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</span>
                                </label>
                                <label class="radio-option">
                                    <input type="radio" name="podcastLanguage" value="english">
                                    <span class="radio-text">ğŸ‡ºğŸ‡¸ English</span>
                                </label>
                            </div>
                        </div>

                        <div class="button-container">
                            <button onclick="generatePodcastContent()" id="generatePodcastBtn" class="primary-btn" aria-describedby="podcast-generate-help">
                                <span class="spinner" id="podcastSpinner"></span>
                                <span id="podcastBtnText">ğŸ¯ ç”Ÿæˆæ’­å®¢å†…å®¹</span>
                            </button>
                        </div>
                        <div id="podcast-generate-help" class="sr-only">æ ¹æ®æ‚¨çš„ä¸»é¢˜ç”Ÿæˆæ’­å®¢å†…å®¹</div>
                    </div>

                    <!-- Script Editor Section -->
                    <div class="script-editor hidden" id="podcastScriptEditor">
                        <div class="voice-selection">
                            <h3>ğŸ­ ä¸ºä¸»æŒäººé€‰æ‹©å£°éŸ³</h3>
                            <div class="character-voices">
                                <div class="voice-select-group">
                                    <label for="hostAVoice">ğŸ¤ ä¸»æŒäºº Aï¼š</label>
                                    <select id="hostAVoice" class="voice-select" aria-describedby="host-a-help">
                                        <option value="">æ­£åœ¨åŠ è½½å£°éŸ³...</option>
                                    </select>
                                    <div id="host-a-help" class="sr-only">ä¸ºç¬¬ä¸€ä½æ’­å®¢ä¸»æŒäººé€‰æ‹©å£°éŸ³</div>
                                </div>
                                <div class="voice-select-group">
                                    <label for="hostBVoice">ğŸ¤ ä¸»æŒäºº Bï¼š</label>
                                    <select id="hostBVoice" class="voice-select" aria-describedby="host-b-help">
                                        <option value="">æ­£åœ¨åŠ è½½å£°éŸ³...</option>
                                    </select>
                                    <div id="host-b-help" class="sr-only">ä¸ºç¬¬äºŒä½æ’­å®¢ä¸»æŒäººé€‰æ‹©å£°éŸ³</div>
                                </div>
                            </div>
                        </div>

                        <div class="script-controls">
                            <button onclick="generatePodcastScript()" id="generateScriptBtn" class="btn primary convert-script" aria-describedby="script-help">
                                <span>ğŸ“</span> è½¬æ¢ä¸ºè„šæœ¬
                            </button>
                            <button onclick="addPodcastDialog('A')" class="action-btn" aria-describedby="add-a-help">
                                <span>â•</span> æ·»åŠ ä¸»æŒäºº A
                            </button>
                            <button onclick="addPodcastDialog('B')" class="action-btn" aria-describedby="add-b-help">
                                <span>â•</span> æ·»åŠ ä¸»æŒäºº B
                            </button>
                            <button onclick="translateAndDownload()" id="translateBtn" class="action-btn" aria-describedby="translate-help">
                                <span>ğŸŒ</span> ç¿»è¯‘å¹¶ä¸‹è½½
                            </button>
                        </div>

                        <!-- Hidden help text -->
                        <div class="sr-only">
                            <div id="script-help">å°†å†…å®¹è½¬æ¢ä¸ºå¯¹è¯è„šæœ¬æ ¼å¼</div>
                            <div id="add-a-help">ä¸ºä¸»æŒäººAæ·»åŠ æ–°çš„å¯¹è¯éƒ¨åˆ†</div>
                            <div id="add-b-help">ä¸ºä¸»æŒäººBæ·»åŠ æ–°çš„å¯¹è¯éƒ¨åˆ†</div>
                            <div id="translate-help">ç¿»è¯‘å†…å®¹å¹¶ä¸‹è½½è„šæœ¬</div>
                        </div>

                        <div id="podcastSections" class="podcast-sections" role="region" aria-label="æ’­å®¢å¯¹è¯éƒ¨åˆ†">
                            <!-- Dialogue sections will be dynamically generated here -->
                        </div>

                        <div class="button-container">
                            <button onclick="generatePodcastAudio()" id="generatePodcastAudioBtn" class="primary-btn" aria-describedby="podcast-audio-help">
                                <span class="spinner" id="podcastAudioSpinner"></span>
                                <span id="podcastAudioBtnText">ğŸµ ç”Ÿæˆæ’­å®¢éŸ³é¢‘</span>
                            </button>
                        </div>
                        <div id="podcast-audio-help" class="sr-only">ä¸ºæ•´ä¸ªæ’­å®¢ç”ŸæˆéŸ³é¢‘</div>

                        <div class="progress-container hidden" id="podcastProgressContainer" role="status" aria-live="polite">
                            <div class="progress-text">
                                æ­£åœ¨ç”Ÿæˆï¼š<span id="podcastCurrentProgress">0</span>/<span id="podcastTotalSections">0</span>
                            </div>
                            <div class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                                <div class="progress" id="podcastProgress"></div>
                            </div>
                        </div>

                        <div class="audio-container">
                            <label for="podcastAudioPlayer" class="sr-only">ç”Ÿæˆçš„æ’­å®¢éŸ³é¢‘</label>
                            <audio id="podcastAudioPlayer" controls preload="none" aria-describedby="podcast-player-help">
                                <source src="" type="audio/mp3">
                                æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
                            </audio>
                            <div id="podcast-player-help" class="sr-only">ç”Ÿæˆæ’­å®¢çš„éŸ³é¢‘æ’­æ”¾å™¨</div>
                        </div>
                    </div>
                </div>
            </section>
        </main>

        <!-- Footer -->
        <footer role="contentinfo" class="footer">
            <p>&copy; 2025 AI ContentCraft. Built with â¤ï¸ for creators.</p>
        </footer>
    </div>

    <script>
        let voices = [];

        // ===== NOTIFICATION SYSTEM =====
        function showNotification(message, type = 'info', duration = 5000) {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(n => n.remove());

            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.setAttribute('role', 'alert');
            notification.setAttribute('aria-live', 'polite');

            const icon = {
                'success': 'âœ…',
                'error': 'âŒ',
                'warning': 'âš ï¸',
                'info': 'â„¹ï¸'
            }[type] || 'â„¹ï¸';

            notification.innerHTML = `
                <div class="notification-content">
                    <span class="notification-icon">${icon}</span>
                    <span class="notification-message">${message}</span>
                    <button class="notification-close" onclick="this.parentElement.parentElement.remove()" aria-label="Close notification">Ã—</button>
                </div>
            `;

            document.body.appendChild(notification);

            // Auto-remove after duration
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateY(-100%)';
                    setTimeout(() => notification.remove(), 300);
                }
            }, duration);
        }

        // ===== LOADING STATE MANAGEMENT =====
        function setLoadingState(element, isLoading, loadingText = 'Loading...', originalText = '') {
            if (isLoading) {
                element.disabled = true;
                element.classList.add('loading');
                const spinner = element.querySelector('.spinner');
                if (spinner) spinner.style.display = 'inline-block';

                const textElement = element.querySelector('span:not(.spinner)');
                if (textElement) {
                    textElement.dataset.originalText = textElement.textContent;
                    textElement.textContent = loadingText;
                }
            } else {
                element.disabled = false;
                element.classList.remove('loading');
                const spinner = element.querySelector('.spinner');
                if (spinner) spinner.style.display = 'none';

                const textElement = element.querySelector('span:not(.spinner)');
                if (textElement) {
                    textElement.textContent = textElement.dataset.originalText || originalText;
                }
            }
        }

        // ===== ACCESSIBILITY HELPERS =====
        function announceToScreenReader(message) {
            const announcement = document.createElement('div');
            announcement.setAttribute('aria-live', 'polite');
            announcement.setAttribute('aria-atomic', 'true');
            announcement.className = 'sr-only';
            announcement.textContent = message;

            document.body.appendChild(announcement);
            setTimeout(() => announcement.remove(), 1000);
        }

        // ===== FORM VALIDATION =====
        function validateForm(formElement) {
            const requiredFields = formElement.querySelectorAll('[required]');
            let isValid = true;

            requiredFields.forEach(field => {
                if (!field.value.trim()) {
                    field.classList.add('error');
                    field.setAttribute('aria-invalid', 'true');
                    isValid = false;
                } else {
                    field.classList.remove('error');
                    field.setAttribute('aria-invalid', 'false');
                }
            });

            return isValid;
        }

        // ===== ELEMENT VISIBILITY HELPERS =====
        function showElement(element) {
            if (typeof element === 'string') {
                element = document.getElementById(element);
            }
            if (element) {
                element.classList.remove('hidden');
                element.style.display = '';
            }
        }

        function hideElement(element) {
            if (typeof element === 'string') {
                element = document.getElementById(element);
            }
            if (element) {
                element.classList.add('hidden');
            }
        }

        function toggleElement(element, show) {
            if (show) {
                showElement(element);
            } else {
                hideElement(element);
            }
        }

        async function loadVoices() {
            try {
                const response = await fetch('/voices');
                voices = await response.json();
                
                // æ›´æ–°æ‰€æœ‰è¯­éŸ³é€‰æ‹©ä¸‹æ‹‰æ¡†
                updateAllVoiceSelects();
                
                // æ›´æ–°ç®€å•TTSçš„è¯­éŸ³é€‰æ‹©
                const simpleTtsVoice = document.getElementById('simpleTtsVoice');
                if (simpleTtsVoice) {
                    const voiceOptionsHtml = voices.map(voice => 
                        `<option value="${voice.id}">${voice.name} (${voice.language}, ${voice.gender})</option>`
                    ).join('');
                    simpleTtsVoice.innerHTML = voiceOptionsHtml;
                    simpleTtsVoice.value = 'Wise_Woman';
                }
            } catch (error) {
                console.error('åŠ è½½å£°éŸ³å¤±è´¥:', error);
                voices = [
                    { id: "Wise_Woman", name: "Wise Woman (Default)", language: "en-us", gender: "Female" }
                ];
                updateAllVoiceSelects();
            }
        }

        function updateAllVoiceSelects() {
            const voiceSelects = document.querySelectorAll('.voice-select');
            const voiceOptionsHtml = voices.map(voice =>
                `<option value="${voice.id}">${voice.name} (${voice.language}, ${voice.gender})</option>`
            ).join('');

            voiceSelects.forEach(select => {
                select.innerHTML = voiceOptionsHtml;

                // ä¸ºæ’­å®¢ä¸»æŒäººè®¾ç½®é»˜è®¤è¯­éŸ³
                if (select.id === 'hostAVoice' || select.id === 'hostBVoice') {
                    const podcastLanguage = document.getElementById('podcastTopic')?.getAttribute('data-language') || 'english';
                    const gender = select.id === 'hostAVoice' ? 'Female' : 'Male';
                    select.value = getDefaultVoiceForLanguage(podcastLanguage, gender);
                } else {
                    select.value = 'Wise_Woman';
                }
            });
        }

        // æ ¹æ®è¯­è¨€é€‰æ‹©åˆé€‚çš„é»˜è®¤è¯­éŸ³
        function getDefaultVoiceForLanguage(language, gender = 'Female') {
            // æ‰€æœ‰è¯­éŸ³éƒ½æ”¯æŒå¤šè¯­è¨€ï¼Œæ ¹æ®æ€§åˆ«é€‰æ‹©åˆé€‚çš„é»˜è®¤è¯­éŸ³
            const suitableVoices = voices.filter(voice => voice.gender === gender);

            if (suitableVoices.length > 0) {
                // æ ¹æ®è¯­è¨€å’Œæ€§åˆ«é€‰æ‹©æ¨èçš„è¯­éŸ³
                if (language === 'chinese') {
                    if (gender === 'Female') {
                        return 'Wise_Woman'; // æ™ºæ…§å¥³å£°
                    } else if (gender === 'Male') {
                        return 'Deep_Voice_Man'; // æ·±æ²‰ç”·å£°
                    }
                } else {
                    if (gender === 'Female') {
                        return 'Calm_Woman'; // å¹³é™å¥³å£°
                    } else if (gender === 'Male') {
                        return 'Elegant_Man'; // ä¼˜é›…ç”·å£°
                    }
                }
                return suitableVoices[0].id;
            }

            // æœ€åçš„å¤‡é€‰æ–¹æ¡ˆ
            return 'Wise_Woman';
        }

        // ç®€å•çš„è¯­è¨€æ£€æµ‹å‡½æ•°
        function detectLanguage(text) {
            // æ£€æµ‹ä¸­æ–‡å­—ç¬¦
            const chineseRegex = /[\u4e00-\u9fff]/;
            if (chineseRegex.test(text)) {
                return 'chinese';
            }
            return 'english';
        }

        // é¡µé¢åŠ è½½æ—¶è·å–å£°éŸ³åˆ—è¡¨
        loadVoices();

        // æ·»åŠ æ’­å®¢è¯­è¨€é€‰æ‹©å˜åŒ–çš„äº‹ä»¶ç›‘å¬å™¨
        document.addEventListener('DOMContentLoaded', function() {
            const podcastLanguageRadios = document.querySelectorAll('input[name="podcastLanguage"]');
            podcastLanguageRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    updatePodcastVoiceDefaults(this.value);
                });
            });
        });

        // æ›´æ–°æ’­å®¢ä¸»æŒäººçš„é»˜è®¤è¯­éŸ³
        function updatePodcastVoiceDefaults(language) {
            const hostAVoice = document.getElementById('hostAVoice');
            const hostBVoice = document.getElementById('hostBVoice');

            if (hostAVoice && hostBVoice) {
                hostAVoice.value = getDefaultVoiceForLanguage(language, 'Female');
                hostBVoice.value = getDefaultVoiceForLanguage(language, 'Male');
            }
        }

        function startProgressSimulation() {
            progress.style.width = '0%';
            let width = 0;
            const interval = setInterval(() => {
                if (width >= 90) {
                    clearInterval(interval);
                    return;
                }
                width += Math.random() * 10;
                progress.style.width = Math.min(width, 90) + '%';
            }, 200);
        }

        function addToHistory(filename, text, voice) {
            const item = document.createElement('div');
            item.className = 'history-item';
            const timestamp = new Date().toLocaleTimeString();
            item.innerHTML = `
                <span>${timestamp}</span>
                <audio controls src="${filename}"></audio>
                <div class="history-text">
                    <div>${text.substring(0, 30)}${text.length > 30 ? '...' : ''}</div>
                    <div class="voice-name">Voice: ${voice}</div>
                </div>
            `;
            historyContainer.insertBefore(item, historyContainer.firstChild);
        }

        let currentTab = 0;
        let audioBuffers = [];

        function switchTab(index) {
            const tabs = document.querySelectorAll('.tab-btn:not(.add-tab)');
            const panels = document.querySelectorAll('.tab-panel');
            
            tabs.forEach(tab => tab.classList.remove('active'));
            panels.forEach(panel => panel.classList.remove('active'));
            
            tabs[index].classList.add('active');
            panels[index].classList.add('active');
            currentTab = index;
        }

        function addNewTab() {
            const tabs = document.querySelector('.tabs');
            const panels = document.querySelector('.tab-panels');
            const newIndex = document.querySelectorAll('.tab-btn:not(.add-tab)').length;
            
            // æ·»åŠ æ–°æ ‡ç­¾æŒ‰é’®
            const tabBtn = document.createElement('button');
            tabBtn.className = 'tab-btn';
            tabBtn.textContent = `éƒ¨åˆ† ${newIndex + 1}`;
            tabBtn.onclick = () => switchTab(newIndex);
            tabs.insertBefore(tabBtn, tabs.lastElementChild);
            
            // æ·»åŠ æ–°é¢æ¿
            const panel = document.createElement('div');
            panel.className = 'tab-panel';
            panel.innerHTML = `
                <textarea class="text-input" placeholder="è¾“å…¥è¦è½¬æ¢ä¸ºè¯­éŸ³çš„æ–‡æœ¬..."></textarea>
                <div class="voice-select-container">
                    <select class="voice-select">
                        ${document.querySelector('.voice-select').innerHTML}
                    </select>
                </div>
            `;
            panels.appendChild(panel);
            
            // è®¾ç½®é»˜è®¤è¯­éŸ³ä¸º Wise Woman
            const voiceSelect = panel.querySelector('.voice-select');
            voiceSelect.value = 'Wise_Woman';
            
            // åˆ‡æ¢åˆ°æ–°æ ‡ç­¾
            switchTab(newIndex);
        }

        async function generateAllAudio() {
            const panels = document.querySelectorAll('.tab-panel');
            const generateBtn = document.getElementById('generateBtn');
            const spinner = document.getElementById('spinner');
            const btnText = document.getElementById('btnText');
            const progressContainer = document.getElementById('storyProgressContainer');
            const progress = document.getElementById('storyProgress');
            
            const sectionsData = Array.from(panels).map(panel => ({
                text: panel.querySelector('.text-input').value.trim(),
                voice: panel.querySelector('.voice-select').value
            })).filter(s => s.text && s.voice);

            if (sectionsData.length === 0) {
                alert('è¯·è¾“å…¥è¦è½¬æ¢çš„æ–‡æœ¬');
                return;
            }

            generateBtn.disabled = true;
            spinner.style.display = 'inline-block';
            btnText.textContent = 'æ­£åœ¨ç”Ÿæˆ...';
            progressContainer.style.display = 'block';
            progress.style.width = '0%';

            try {
                // è·å–æ•…äº‹çš„è¯­è¨€ä¿¡æ¯
                const storyLanguage = document.getElementById('storyText').getAttribute('data-language') || 'english';

                const response = await fetch('/generate-and-merge', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sections: sectionsData, language: storyLanguage })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    const lines = decoder.decode(value).split('\n');
                    for (const line of lines) {
                        if (!line.trim()) continue;
                        
                        try {
                            const data = JSON.parse(line);
                            if (data.type === 'progress') {
                                progress.style.width = `${(data.current / data.total) * 100}%`;
                            } else if (data.type === 'complete' && data.success) {
                                const audioPlayer = document.getElementById('multiAudioPlayer');
                                audioPlayer.src = data.filename;
                                audioPlayer.load();
                                
                                // å¯ç”¨å¯¼å‡ºæŒ‰é’®
                                document.getElementById('exportBtn').disabled = false;
                                
                                // æ·»åŠ åˆ°å†å²è®°å½•
                                addToHistory(data.filename, `åˆå¹¶éŸ³é¢‘ (${sectionsData.length} ä¸ªéƒ¨åˆ†)`, 'å¤šä¸ª');
                            }
                        } catch (e) {
                            console.warn('Failed to parse line:', line, e);
                        }
                    }
                }
            } catch (error) {
                alert('ç”Ÿæˆå¤±è´¥ï¼š' + error.message);
            } finally {
                generateBtn.disabled = false;
                spinner.style.display = 'none';
                btnText.textContent = 'ç”Ÿæˆæ‰€æœ‰éŸ³é¢‘';
            }
        }

        async function exportMergedAudio() {
            const audioPlayer = document.getElementById('multiAudioPlayer');
            if (!audioPlayer.src) {
                alert('è¯·å…ˆç”ŸæˆéŸ³é¢‘');
                return;
            }

            try {
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const link = document.createElement('a');
                link.href = audioPlayer.src;
                link.download = `merged-${new Date().toISOString().replace(/[:.]/g, '-')}.wav`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                alert('å¯¼å‡ºå¤±è´¥ï¼š' + error.message);
            }
        }

        async function generateStory() {
            const theme = document.getElementById('themeInput').value.trim();
            if (!theme) {
                showNotification('è¯·è¾“å…¥æ•…äº‹ä¸»é¢˜', 'warning');
                document.getElementById('themeInput').focus();
                return;
            }

            // Get selected language
            const selectedLanguage = document.querySelector('input[name="storyLanguage"]:checked').value;

            const generateStoryBtn = document.getElementById('generateStoryBtn');
            const storyText = document.getElementById('storyText');
            const spinner = document.getElementById('storySpinner');
            const btnText = document.getElementById('generateStoryText');

            // Update UI state
            generateStoryBtn.disabled = true;
            spinner.style.display = 'inline-block';
            btnText.textContent = 'æ­£åœ¨ç”Ÿæˆæ•…äº‹...';
            storyText.value = '';

            try {
                const response = await fetch('/generate-story', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ theme, language: selectedLanguage })
                });

                const data = await response.json();
                if (data.success) {
                    storyText.value = data.story;
                    storyText.removeAttribute('readonly');

                    // ä¿å­˜æ•…äº‹è¯­è¨€ä¿¡æ¯åˆ°æ•°æ®å±æ€§
                    storyText.setAttribute('data-language', data.language || selectedLanguage);

                    showNotification('æ•…äº‹ç”ŸæˆæˆåŠŸï¼', 'success');

                    // Scroll to story text for better UX
                    storyText.scrollIntoView({ behavior: 'smooth', block: 'center' });
                } else {
                    throw new Error(data.error || 'ç”Ÿæˆæ•…äº‹å¤±è´¥');
                }
            } catch (error) {
                console.error('Story generation error:', error);
                showNotification('ç”Ÿæˆæ•…äº‹å¤±è´¥ï¼š' + error.message, 'error');
            } finally {
                generateStoryBtn.disabled = false;
                spinner.style.display = 'none';
                btnText.textContent = 'ğŸ¯ ç”Ÿæˆæ•…äº‹';
            }
        }

        async function generateScript() {
            const storyText = document.getElementById('storyText').value;
            if (!storyText) {
                alert('è¯·å…ˆç”Ÿæˆä¸€ä¸ªæ•…äº‹');
                return;
            }

            const convertToScript = document.getElementById('convertToScript');

            // è®¾ç½®æŒ‰é’®ä¸ºç”Ÿæˆä¸­çŠ¶æ€
            convertToScript.disabled = true;
            convertToScript.innerHTML = '<span class="spinner" id="convertSpinner" style="display: inline-block;"></span><span>æ­£åœ¨ç”Ÿæˆ...</span>';

            const scriptSections = document.getElementById('scriptSections');
            scriptSections.innerHTML = ''; // æ¸…ç©ºç°æœ‰å†…å®¹
            
            try {
                // è·å–æ•…äº‹çš„è¯­è¨€ä¿¡æ¯
                const storyLanguage = document.getElementById('storyText').getAttribute('data-language') || 'english';

                const response = await fetch('/generate-script', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ story: storyText, language: storyLanguage })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    
                    const lines = decoder.decode(value).split('\n');
                    for (const line of lines) {
                        if (!line) continue;
                        
                        const data = JSON.parse(line);
                        switch (data.type) {
                            case 'status':
                                convertToScript.textContent = data.message;
                                break;
                            case 'complete':
                                if (data.success && data.script && data.script.scenes) {
                                    // ä¸ºæ¯ä¸ªåœºæ™¯åˆ›å»ºä¸€ä¸ªæ®µè½
                                    data.script.scenes.forEach((scene, index) => {
                                        const section = createScriptSection(scene, index);
                                        scriptSections.appendChild(section);
                                    });

                                    // æ˜¾ç¤ºæ‰€æœ‰æŒ‰é’®
                                    showElement('generateStoryAudioBtn');
                                    showElement('downloadImages');
                                    
                                    // æ·»åŠ è„šæœ¬æ§åˆ¶æŒ‰é’®
                                    const scriptControls = document.createElement('div');
                                    scriptControls.className = 'script-controls';
                                    scriptControls.style.marginTop = '20px';
                                    scriptControls.style.display = 'flex';
                                    scriptControls.style.gap = '10px';
                                    scriptControls.innerHTML = `
                                        <button onclick="addScriptSection('narration')" class="btn secondary">
                                            æ·»åŠ æ—ç™½
                                        </button>
                                        <button onclick="addScriptSection('dialogue')" class="btn secondary">
                                            æ·»åŠ å¯¹è¯
                                        </button>
                                        <button onclick="downloadScript('json')" class="btn secondary">
                                            ä¸‹è½½ JSON
                                        </button>
                                        <button onclick="downloadScript('txt')" class="btn secondary">
                                            ä¸‹è½½ TXT
                                        </button>
                                    `;
                                    scriptSections.appendChild(scriptControls);
                                    
                                    // æ·»åŠ æ‰¹é‡ç”Ÿæˆå›¾ç‰‡çš„æŒ‰é’®
                                    scriptSections.appendChild(createImageButtons());
                                }
                                break;
                            case 'error':
                                throw new Error(data.error);
                        }
                    }
                }
            } catch (error) {
                alert('è½¬æ¢è„šæœ¬å¤±è´¥ï¼š' + error.message);
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                convertToScript.disabled = false;
                convertToScript.style.backgroundColor = '';  // æ¸…é™¤å†…è”æ ·å¼ï¼Œä½¿ç”¨CSSç±»æ ·å¼
                convertToScript.innerHTML = '<span class="spinner" id="convertSpinner"></span><span id="convertText">ğŸ“ è½¬æ¢ä¸ºè„šæœ¬</span>';
            }
        }

        // ä¿®æ”¹ createImageButtons å‡½æ•°
        function createImageButtons() {
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'button-container';
            buttonContainer.style.marginTop = '20px';
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '10px';
            buttonContainer.innerHTML = `
                <button onclick="generateStoryAudio()" class="primary-btn">
                    ç”ŸæˆéŸ³é¢‘
                </button>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="imageModelSelect" style="font-weight: bold; color: #333;">AI æ¨¡å‹ï¼š</label>
                    <select id="imageModelSelect" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white;">
                        <option value="black-forest-labs/flux-schnell" selected>FLUX Schnell</option>
                        <option value="black-forest-labs/flux-dev">FLUX Dev</option>
                        <option value="black-forest-labs/flux-1.1-pro">FLUX 1.1 Pro</option>
                        <option value="black-forest-labs/flux-kontext-pro">FLUX Kontext Pro</option>
                        <option value="black-forest-labs/flux-kontext-max">FLUX Kontext Max</option>
                    </select>
                </div>
                <button onclick="generateAllImages()" id="generateAllImagesBtn" class="primary-btn">
                    ç”Ÿæˆæ‰€æœ‰å›¾ç‰‡
                </button>
                <button onclick="downloadAllImages()" class="primary-btn">
                    ä¸‹è½½æ‰€æœ‰å›¾ç‰‡
                </button>
            `;
            return buttonContainer;
        }

        function createScriptSection(scene, index) {
            const section = document.createElement('div');
            section.className = 'script-section';
            section.draggable = true;
            section.id = `section-${Date.now()}-${index}`;
            
            // æ·»åŠ æ‹–åŠ¨äº‹ä»¶
            section.addEventListener('dragstart', handleDragStart);
            section.addEventListener('dragend', handleDragEnd);
            section.addEventListener('dragover', handleDragOver);
            section.addEventListener('drop', handleDrop);

            const header = document.createElement('div');
            header.className = 'section-header';

            // æ·»åŠ ç±»å‹æ ‡ç­¾
            const typeLabel = document.createElement('span');
            typeLabel.className = `section-type ${scene.type}`;
            typeLabel.textContent = scene.type === 'narration' ? 'æ—ç™½' : 'å¯¹è¯';
            header.appendChild(typeLabel);

            // æ·»åŠ æ§åˆ¶æŒ‰é’®
            const controls = document.createElement('div');
            controls.className = 'section-controls';

            // æ·»åŠ è¯­éŸ³é€‰æ‹©
            const voiceSelect = document.createElement('select');
            voiceSelect.className = 'voice-select';
            const voiceOptionsHtml = voices.map(voice =>
                `<option value="${voice.id}">${voice.name} (${voice.language}, ${voice.gender})</option>`
            ).join('');
            voiceSelect.innerHTML = voiceOptionsHtml;

            // æ ¹æ®æ•…äº‹è¯­è¨€å’Œåœºæ™¯ç±»å‹é€‰æ‹©åˆé€‚çš„é»˜è®¤è¯­éŸ³
            const storyLanguage = document.getElementById('storyText').getAttribute('data-language') || 'english';
            const defaultGender = scene.type === 'dialogue' ? 'Male' : 'Female';
            voiceSelect.value = getDefaultVoiceForLanguage(storyLanguage, defaultGender);

            // æ·»åŠ åˆ é™¤æŒ‰é’®
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = 'Delete';
            deleteBtn.onclick = () => section.remove();

            controls.appendChild(voiceSelect);
            controls.appendChild(deleteBtn);
            header.appendChild(controls);

            const content = document.createElement('div');
            content.className = 'section-content';

            // å¦‚æœæ˜¯å¯¹è¯ï¼Œæ·»åŠ è§’è‰²åæ˜¾ç¤º
            if (scene.type === 'dialogue' && scene.character) {
                const characterLabel = document.createElement('div');
                characterLabel.className = 'character-label';
                characterLabel.textContent = scene.character;
                content.appendChild(characterLabel);
            }

            // æ·»åŠ æ–‡æœ¬åŒºåŸŸ
            const textarea = document.createElement('textarea');
            textarea.className = 'text-input';
            textarea.value = scene.text;
            textarea.placeholder = scene.type === 'dialogue' ? 'è¾“å…¥å¯¹è¯...' : 'è¾“å…¥æ—ç™½...';
            content.appendChild(textarea);

            section.appendChild(header);
            section.appendChild(content);

            // æ·»åŠ å›¾ç‰‡å®¹å™¨
            const imageContainer = document.createElement('div');
            imageContainer.className = 'section-image-container';
            const uniqueId = `section-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            imageContainer.innerHTML = `
                <div class="image-controls">
                    <button class="generate-image-btn">ç”Ÿæˆå›¾ç‰‡</button>
                    <div class="model-select-container">
                        <label for="sectionModel-${uniqueId}" class="model-label">æ¨¡å‹ï¼š</label>
                        <select id="sectionModel-${uniqueId}" class="section-model-select">
                            <option value="black-forest-labs/flux-schnell" selected>FLUX Schnell</option>
                            <option value="black-forest-labs/flux-dev">FLUX Dev</option>
                            <option value="black-forest-labs/flux-1.1-pro">FLUX 1.1 Pro</option>
                            <option value="black-forest-labs/flux-kontext-pro">FLUX Kontext Pro</option>
                            <option value="black-forest-labs/flux-kontext-max">FLUX Kontext Max</option>
                        </select>
                    </div>
                </div>
                <div class="image-loading" style="display: none;">
                    <span class="spinner"></span>
                    <span>æ­£åœ¨ç”Ÿæˆå›¾ç‰‡...</span>
                </div>
                <div class="image-prompt" style="display: none;"></div>
                <div class="image-preview">
                    <img style="max-width: 100%; display: none;" />
                    <div class="regenerate-controls" style="display: none;">
                        <button class="regenerate-btn">é‡æ–°ç”Ÿæˆ</button>
                        <select class="regenerate-model-select">
                            <option value="black-forest-labs/flux-schnell">FLUX Schnell</option>
                            <option value="black-forest-labs/flux-dev">FLUX Dev</option>
                            <option value="black-forest-labs/flux-1.1-pro">FLUX 1.1 Pro</option>
                            <option value="black-forest-labs/flux-kontext-pro">FLUX Kontext Pro</option>
                            <option value="black-forest-labs/flux-kontext-max">FLUX Kontext Max</option>
                        </select>
                    </div>
                </div>
            `;
            
            // ç»‘å®šç”Ÿæˆå›¾ç‰‡æŒ‰é’®äº‹ä»¶
            const generateImageBtn = imageContainer.querySelector('.generate-image-btn');
            generateImageBtn.onclick = () => generateSectionImage(section, scene.text);
            
            section.appendChild(imageContainer);
            return section;
        }

        async function generateSectionImage(section, text, isRegenerate = false) {
            if (!text) {
                alert('æ²¡æœ‰å¯ç”¨äºå›¾åƒç”Ÿæˆçš„æ–‡æœ¬');
                return;
            }

            const imageContainer = section.querySelector('.section-image-container');
            const generateBtn = imageContainer.querySelector('.generate-image-btn');
            const loading = imageContainer.querySelector('.image-loading');
            const preview = imageContainer.querySelector('.image-preview');
            const promptDiv = imageContainer.querySelector('.image-prompt');
            const img = preview.querySelector('img');
            const regenerateControls = preview.querySelector('.regenerate-controls');
            const regenerateBtn = preview.querySelector('.regenerate-btn');
            const regenerateModelSelect = preview.querySelector('.regenerate-model-select');

            generateBtn.disabled = true;
            loading.style.display = 'flex';
            img.style.display = 'none';
            promptDiv.style.display = 'none';
            regenerateControls.style.display = 'none';
            
            try {
                // 1. ç”Ÿæˆæç¤ºè¯
                const promptResponse = await fetch('/generate-image-prompt', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        text: text,
                        context: document.getElementById('storyText').value 
                    })
                });
                
                if (!promptResponse.ok) {
                    throw new Error(`Failed to generate prompt: ${promptResponse.status}`);
                }
                
                const promptData = await promptResponse.json();
                if (!promptData.success || !promptData.prompt) {
                    throw new Error('Invalid prompt response');
                }

                // 2. ä½¿ç”¨æç¤ºè¯ç”Ÿæˆå›¾ç‰‡
                let selectedModel;
                if (isRegenerate) {
                    // é‡æ–°ç”Ÿæˆæ—¶ä½¿ç”¨é‡æ–°ç”Ÿæˆæ§ä»¶ä¸­çš„æ¨¡å‹é€‰æ‹©
                    selectedModel = regenerateModelSelect?.value || 'black-forest-labs/flux-schnell';
                } else {
                    // é¦–æ¬¡ç”Ÿæˆæ—¶ä½¿ç”¨è¯¥æ®µè½çš„æ¨¡å‹é€‰æ‹©å™¨
                    const sectionModelSelect = imageContainer.querySelector('.section-model-select');
                    selectedModel = sectionModelSelect?.value || 'black-forest-labs/flux-schnell';
                }

                const imageResponse = await fetch('/generate-image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: promptData.prompt,
                        sectionId: section.id,
                        seed: isRegenerate ? Math.floor(Math.random() * 1000000) : 1234,
                        model: selectedModel
                    })
                });

                if (!imageResponse.ok) {
                    const errorText = await imageResponse.text();
                    console.error('Image generation HTTP error:', imageResponse.status, errorText);
                    throw new Error(`Image generation failed (${imageResponse.status}): ${errorText}`);
                }

                const imageData = await imageResponse.json();
                if (!imageData.success) {
                    console.error('Image generation API error:', imageData.error);
                    throw new Error(imageData.error || 'Image generation failed');
                }

                // å¢å¼ºçš„ URL å¤„ç†é€»è¾‘
                let imageUrl;
                if (Array.isArray(imageData.imageUrl)) {
                    imageUrl = imageData.imageUrl[0];
                } else if (typeof imageData.imageUrl === 'string') {
                    imageUrl = imageData.imageUrl;
                } else if (typeof imageData.imageUrl === 'object' && imageData.imageUrl !== null) {
                    imageUrl = imageData.imageUrl.url || imageData.imageUrl.output || imageData.imageUrl.image;
                }

                // URL éªŒè¯
                if (!imageUrl || typeof imageUrl !== 'string') {
                    throw new Error('Invalid image URL format');
                }

                if (!imageUrl.startsWith('http')) {
                    throw new Error('Invalid image URL protocol');
                }

                // 3. æ˜¾ç¤ºç»“æœ
                promptDiv.textContent = promptData.prompt;
                promptDiv.style.display = 'block';

                // åˆ›å»ºæ–°å›¾ç‰‡å…ƒç´ 
                const newImg = document.createElement('img');
                newImg.style.maxWidth = '100%';
                newImg.style.display = 'none';
                
                // è®¾ç½®åŠ è½½äº‹ä»¶
                newImg.onload = () => {
                    loading.style.display = 'none';
                    newImg.style.display = 'block';
                    regenerateControls.style.display = 'flex';

                    // è®¾ç½®é‡æ–°ç”Ÿæˆæ¨¡å‹é€‰æ‹©å™¨çš„é»˜è®¤å€¼ä¸ºå½“å‰ä½¿ç”¨çš„æ¨¡å‹
                    if (regenerateModelSelect) {
                        regenerateModelSelect.value = selectedModel;
                    }
                };

                // è®¾ç½®é”™è¯¯äº‹ä»¶
                newImg.onerror = () => {
                    loading.style.display = 'none';
                    console.error('Failed to load image:', imageUrl);
                    throw new Error('Failed to load image from URL');
                };

                // è®¾ç½®å›¾ç‰‡å±æ€§
                newImg.src = imageUrl;
                newImg.dataset.prompt = promptData.prompt;

                // æ›¿æ¢æ—§å›¾ç‰‡
                const oldImg = preview.querySelector('img');
                if (oldImg) {
                    preview.replaceChild(newImg, oldImg);
                } else {
                    preview.appendChild(newImg);
                }

                // æ›´æ–°é‡æ–°ç”ŸæˆæŒ‰é’®çš„äº‹ä»¶å¤„ç†
                regenerateBtn.onclick = () => generateSectionImage(section, text, true);
                
            } catch (error) {
                console.error('Image generation error:', error);
                loading.style.display = 'none';
                alert('ç”Ÿæˆå›¾åƒå¤±è´¥ï¼š' + error.message);
            } finally {
                generateBtn.disabled = false;
            }
        }

        function openImageModal(url, prompt) {
            const modal = document.createElement('div');
            modal.className = 'image-modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <img src="${url}" alt="Generated image" />
                    <p class="prompt-text">${prompt}</p>
                    <button onclick="this.closest('.image-modal').remove()">Close</button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        async function generateStoryAudio() {
            const sections = document.querySelectorAll('.script-section');
            const generateBtn = document.getElementById('generateStoryAudioBtn');
            const progressContainer = document.getElementById('storyProgressContainer');
            const progressBar = document.getElementById('storyProgress');
            const currentProgress = document.getElementById('storyCurrentProgress');
            const totalSections = document.getElementById('storyTotalSections');

            generateBtn.disabled = true;
            const spinner = generateBtn.querySelector('.spinner');
            const btnText = generateBtn.querySelector('#storyBtnText');
            spinner.style.display = 'inline-block';
            btnText.textContent = 'Generating...';
            progressContainer.style.display = 'block';

            try {
                const sectionsData = Array.from(sections).map(section => ({
                    text: section.querySelector('.text-input').value,
                    voice: section.querySelector('.voice-select').value
                }));

                const response = await fetch('/generate-and-merge', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sections: sectionsData })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    const lines = decoder.decode(value).split('\n');
                    for (const line of lines) {
                        if (!line.trim()) continue;
                        
                        try {
                            const data = JSON.parse(line);
                            if (data.type === 'progress') {
                                currentProgress.textContent = data.current;
                                totalSections.textContent = data.total;
                                progressBar.style.width = `${(data.current / data.total) * 100}%`;
                            } else if (data.type === 'complete' && data.success) {
                                const audioPlayer = document.getElementById('storyAudioPlayer');
                                audioPlayer.src = data.filename;
                                audioPlayer.load();
                            }
                        } catch (e) {
                            console.warn('Failed to parse line:', line, e);
                        }
                    }
                }
            } catch (error) {
                console.error('Audio generation error:', error);
                alert('ç”ŸæˆéŸ³é¢‘å¤±è´¥ï¼š' + error.message);
            } finally {
                generateBtn.disabled = false;
                spinner.style.display = 'none';
                btnText.textContent = 'ç”ŸæˆéŸ³é¢‘';
            }
        }

        let draggedElement = null;

        function handleDragStart(e) {
            draggedElement = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            draggedElement = null;
            
            document.querySelectorAll('.drag-placeholder').forEach(p => p.remove());
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const container = document.getElementById('scriptSections');
            const sections = [...container.children];
            
            if (this !== draggedElement) {
                const draggedRect = draggedElement.getBoundingClientRect();
                const targetRect = this.getBoundingClientRect();
                const draggedIndex = sections.indexOf(draggedElement);
                const targetIndex = sections.indexOf(this);
                
                if (draggedIndex < targetIndex) {
                    this.parentNode.insertBefore(draggedElement, this.nextSibling);
                } else {
                    this.parentNode.insertBefore(draggedElement, this);
                }
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // Enhanced page switching function with accessibility support
        function switchPage(pageId) {
            // Update navigation button states
            document.querySelectorAll('.nav-button').forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-pressed', 'false');
            });

            const activeBtn = document.querySelector(`.nav-button[onclick*="${pageId}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
                activeBtn.setAttribute('aria-pressed', 'true');
            }

            // Update page display with fade animation
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
                page.setAttribute('aria-hidden', 'true');
            });

            const activePage = document.getElementById(`${pageId}Page`);
            if (activePage) {
                activePage.classList.add('active');
                activePage.setAttribute('aria-hidden', 'false');

                // Focus management for accessibility
                const firstFocusable = activePage.querySelector('input, textarea, button, select');
                if (firstFocusable) {
                    setTimeout(() => firstFocusable.focus(), 100);
                }
            }

            // Update page title
            const pageTitles = {
                'story': 'æ•…äº‹ç”Ÿæˆå™¨',
                'simple': 'ç®€å•è¯­éŸ³åˆæˆ',
                'multi': 'å¤šå£°éŸ³è¯­éŸ³åˆæˆ',
                'podcast': 'æ’­å®¢ç”Ÿæˆå™¨'
            };
            document.title = `${pageTitles[pageId]} - AI ContentCraft`;
        }

        // Enhanced Simple TTS generation function
        async function generateSimpleTTS() {
            const text = document.getElementById('simpleTtsText').value.trim();
            const voice = document.getElementById('simpleTtsVoice').value;

            if (!text) {
                showNotification('è¯·è¾“å…¥è¦è½¬æ¢çš„æ–‡æœ¬', 'warning');
                document.getElementById('simpleTtsText').focus();
                return;
            }

            if (!voice) {
                showNotification('è¯·é€‰æ‹©ä¸€ä¸ªå£°éŸ³', 'warning');
                document.getElementById('simpleTtsVoice').focus();
                return;
            }

            const button = document.getElementById('simpleTtsBtn');
            const spinner = document.getElementById('simpleTtsSpinner');
            const buttonText = document.getElementById('simpleTtsButtonText');

            // Update UI state
            setLoadingState(button, true, 'ğŸµ æ­£åœ¨ç”ŸæˆéŸ³é¢‘...');

            try {
                announceToScreenReader('æ­£åœ¨ç”ŸæˆéŸ³é¢‘ï¼Œè¯·ç¨å€™');

                // æ£€æµ‹æ–‡æœ¬è¯­è¨€
                const detectedLanguage = detectLanguage(text);

                const response = await fetch('/generate-and-merge', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sections: [{
                            text: text,
                            voice: voice
                        }],
                        language: detectedLanguage
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    const lines = decoder.decode(value).split('\n');
                    for (const line of lines) {
                        if (!line.trim()) continue;

                        try {
                            const data = JSON.parse(line);
                            if (data.type === 'complete' && data.success) {
                                const audioPlayer = document.getElementById('simpleTtsPlayer');
                                audioPlayer.src = data.filename;
                                audioPlayer.load();

                                showNotification('éŸ³é¢‘ç”ŸæˆæˆåŠŸï¼', 'success');
                                announceToScreenReader('éŸ³é¢‘ç”Ÿæˆå®Œæˆ');

                                // Scroll to audio player
                                audioPlayer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        } catch (e) {
                            console.warn('Failed to parse line:', line, e);
                        }
                    }
                }
            } catch (error) {
                console.error('TTS generation error:', error);
                showNotification('ç”ŸæˆéŸ³é¢‘å¤±è´¥ï¼š' + error.message, 'error');
                announceToScreenReader('éŸ³é¢‘ç”Ÿæˆå¤±è´¥');
            } finally {
                setLoadingState(button, false, '', 'ğŸµ ç”ŸæˆéŸ³é¢‘');
            }
        }

        async function generateMultiAudio() {
            const sections = document.querySelectorAll('.script-section');
            if (sections.length === 0) {
                alert('æ²¡æœ‰å¯ç”ŸæˆéŸ³é¢‘çš„éƒ¨åˆ†');
                return;
            }

            const generateBtn = document.getElementById('generateMultiBtn');
            const spinner = document.getElementById('multiSpinner');
            const buttonText = document.getElementById('multiButtonText');
            const progressContainer = document.getElementById('multiProgressContainer');
            const progressBar = document.getElementById('multiProgress');
            const currentProgress = document.getElementById('currentProgress');
            const totalSections = document.getElementById('totalSections');

            // è®¾ç½®åˆå§‹çŠ¶æ€
            generateBtn.disabled = true;
            spinner.style.display = 'inline-block';
            buttonText.textContent = 'Generating...';
            progressContainer.style.display = 'block';
            totalSections.textContent = sections.length;
            currentProgress.textContent = '0';
            progressBar.style.width = '0%';

            try {
                // æ”¶é›†æ‰€æœ‰æ®µè½æ•°æ®
                const sectionsData = Array.from(sections).map(section => {
                    const textarea = section.querySelector('textarea');
                    const voiceSelect = section.querySelector('.voice-select');
                    return {
                        text: textarea.value.trim(),
                        voice: voiceSelect.value
                    };
                }).filter(s => s.text && s.voice);

                if (sectionsData.length === 0) {
                    throw new Error('No valid text sections found');
                }

                // ä¸€æ¬¡æ€§å‘é€æ‰€æœ‰æ•°æ®è¿›è¡Œå¤„ç†
                const response = await fetch('/generate-and-merge', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sections: sectionsData })
                });

                const data = await response.json();
                if (data.success) {
                    // æ›´æ–°éŸ³é¢‘æ’­æ”¾å™¨
                    const audioPlayer = document.getElementById('multiAudioPlayer');
                    audioPlayer.src = data.filename;
                    audioPlayer.load();
                    
                    // è®¾ç½®è¿›åº¦ä¸º 100%
                    currentProgress.textContent = sections.length;
                    progressBar.style.width = '100%';
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                alert('éŸ³é¢‘ç”Ÿæˆå¤±è´¥ï¼š' + error.message);
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                generateBtn.disabled = false;
                spinner.style.display = 'none';
                buttonText.textContent = 'ç”ŸæˆéŸ³é¢‘';
                
                // å»¶è¿Ÿéšè—è¿›åº¦æ¡
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                    progressBar.style.width = '0%';
                }, 1000);
            }
        }

        // æ·»åŠ æ’­å®¢ç›¸å…³çš„ JavaScript å‡½æ•°
        async function generatePodcastContent() {
            const topic = document.getElementById('podcastTopic').value.trim();
            if (!topic) {
                alert('è¯·è¾“å…¥ä¸€ä¸ªä¸»é¢˜');
                return;
            }

            // Get selected language
            const selectedLanguage = document.querySelector('input[name="podcastLanguage"]:checked').value;

            const button = document.getElementById('generatePodcastBtn');
            const spinner = document.getElementById('podcastSpinner');
            const btnText = document.getElementById('podcastBtnText');

            button.disabled = true;
            spinner.style.display = 'inline-block';
            btnText.textContent = 'æ­£åœ¨ç”Ÿæˆ...';

            try {
                const response = await fetch('/generate-podcast', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ topic, language: selectedLanguage })
                });

                const data = await response.json();
                if (data.success) {
                    const podcastTopicElement = document.getElementById('podcastTopic');
                    podcastTopicElement.value = data.content;

                    // ä¿å­˜æ’­å®¢è¯­è¨€ä¿¡æ¯åˆ°æ•°æ®å±æ€§
                    podcastTopicElement.setAttribute('data-language', data.language || selectedLanguage);

                    showElement('podcastScriptEditor');
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                alert('ç”Ÿæˆæ’­å®¢å†…å®¹å¤±è´¥ï¼š' + error.message);
            } finally {
                button.disabled = false;
                spinner.style.display = 'none';
                btnText.textContent = 'ç”Ÿæˆæ’­å®¢å†…å®¹';
            }
        }

        async function generatePodcastScript() {
            const content = document.getElementById('podcastTopic').value.trim();
            if (!content) {
                alert('è¯·å…ˆç”Ÿæˆæˆ–è¾“å…¥æ’­å®¢å†…å®¹');
                return;
            }

            // è·å–æ’­å®¢è¯­è¨€ä¿¡æ¯
            const podcastLanguage = document.getElementById('podcastTopic').getAttribute('data-language') ||
                                  document.querySelector('input[name="podcastLanguage"]:checked').value;

            const button = document.getElementById('generateScriptBtn');
            button.disabled = true;
            button.innerHTML = '<span>â³</span> æ­£åœ¨è½¬æ¢...';

            try {
                const response = await fetch('/generate-podcast-script', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content, language: podcastLanguage })
                });

                const data = await response.json();
                if (data.success) {
                    const container = document.getElementById('podcastSections');
                    container.innerHTML = '';

                    data.script.forEach((dialog, index) => {
                        const section = createPodcastDialog(dialog.host, dialog.text, index);
                        container.appendChild(section);
                    });

                    // æ ¹æ®å½“å‰è¯­è¨€è®¾ç½®æ›´æ–°ä¸»æŒäººè¯­éŸ³
                    updatePodcastVoiceDefaults(podcastLanguage);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                alert('è½¬æ¢ä¸ºè„šæœ¬å¤±è´¥ï¼š' + error.message);
            } finally {
                button.disabled = false;
                button.innerHTML = '<span>ğŸ“</span> è½¬æ¢ä¸ºè„šæœ¬';
            }
        }

        function createPodcastDialog(host, text, index) {
            const section = document.createElement('div');
            section.className = 'podcast-dialog';
            section.draggable = true;
            section.dataset.index = index;

            // æ·»åŠ æ‹–æ‹½äº‹ä»¶
            section.addEventListener('dragstart', handleDragStart);
            section.addEventListener('dragend', handleDragEnd);
            section.addEventListener('dragover', handleDragOver);
            section.addEventListener('drop', handleDrop);

            const hostLabel = document.createElement('div');
            hostLabel.className = `host-label host-${host.toLowerCase()}`;
            hostLabel.textContent = `ä¸»æŒäºº ${host}`;
            section.appendChild(hostLabel);

            const textarea = document.createElement('textarea');
            textarea.className = 'text-input';
            textarea.value = text;
            section.appendChild(textarea);

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = 'åˆ é™¤';
            deleteBtn.onclick = () => section.remove();
            section.appendChild(deleteBtn);

            return section;
        }

        function addPodcastDialog(host) {
            const container = document.getElementById('podcastSections');
            const section = createPodcastDialog(host, '', container.children.length);
            container.appendChild(section);
        }

        async function generatePodcastAudio() {
            const sections = document.querySelectorAll('.podcast-dialog');
            const topic = document.getElementById('podcastTopic').value.trim();
            
            if (sections.length === 0) {
                alert('æœªæ‰¾åˆ°å¯¹è¯éƒ¨åˆ†');
                return;
            }

            const hostAVoice = document.getElementById('hostAVoice').value;
            const hostBVoice = document.getElementById('hostBVoice').value;

            const button = document.getElementById('generatePodcastAudioBtn');
            const spinner = document.getElementById('podcastAudioSpinner');
            const btnText = document.getElementById('podcastAudioBtnText');
            const progressContainer = document.getElementById('podcastProgressContainer');
            const progress = document.getElementById('podcastProgress');
            const currentProgress = document.getElementById('podcastCurrentProgress');
            const totalSections = document.getElementById('podcastTotalSections');

            button.disabled = true;
            spinner.style.display = 'inline-block';
            btnText.textContent = 'Generating...';
            progressContainer.style.display = 'block';
            totalSections.textContent = sections.length;
            currentProgress.textContent = '0';
            progress.style.width = '0%';

            try {
                const sectionsData = Array.from(sections).map(section => {
                    const host = section.querySelector('.host-label').textContent.includes('A') ? 'A' : 'B';
                    return {
                        text: section.querySelector('textarea').value.trim(),
                        voice: host === 'A' ? hostAVoice : hostBVoice
                    };
                }).filter(s => s.text);

                // è·å–æ’­å®¢çš„è¯­è¨€ä¿¡æ¯
                const podcastLanguage = document.getElementById('podcastTopic').getAttribute('data-language') || 'english';

                const response = await fetch('/generate-and-merge', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sections: sectionsData,
                        theme: topic.substring(0, 20),
                        language: podcastLanguage
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    
                    const lines = decoder.decode(value).split('\n');
                    for (const line of lines) {
                        if (!line) continue;
                        
                        const data = JSON.parse(line);
                        switch (data.type) {
                            case 'progress':
                                currentProgress.textContent = data.current;
                                progress.style.width = `${(data.current / data.total) * 100}%`;
                                break;
                            case 'status':
                                btnText.textContent = data.message;
                                break;
                            case 'complete':
                                if (data.success) {
                                    const audioPlayer = document.getElementById('podcastAudioPlayer');
                                    audioPlayer.src = data.filename;
                                    audioPlayer.load();
                                    progress.style.width = '100%';
                                }
                                break;
                            case 'error':
                                throw new Error(data.error);
                        }
                    }
                }
            } catch (error) {
                alert('ç”ŸæˆéŸ³é¢‘å¤±è´¥ï¼š' + error.message);
            } finally {
                button.disabled = false;
                spinner.style.display = 'none';
                btnText.textContent = 'ç”ŸæˆéŸ³é¢‘';
                
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                    progress.style.width = '0%';
                }, 1000);
            }
        }

        async function generateStoryImage() {
            const storyText = document.getElementById('storyText').value;
            if (!storyText) {
                alert('è¯·å…ˆç”Ÿæˆä¸€ä¸ªæ•…äº‹');
                return;
            }

            const btn = document.getElementById('generateImageBtn');
            const imgContainer = document.getElementById('storyImage');
            const imgDisplay = document.getElementById('storyImageDisplay');
            
            btn.disabled = true;
            btn.textContent = 'Generating...';
            imgDisplay.style.display = 'block';
            imgContainer.style.display = 'none';
            
            try {
                // ç”Ÿæˆ prompt
                const promptResponse = await fetch('/generate-image-prompt', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: storyText })
                });
                
                if (!promptResponse.ok) {
                    throw new Error(`Prompt generation failed: ${promptResponse.status}`);
                }
                
                const promptData = await promptResponse.json();
                if (!promptData.success || !promptData.prompt) {
                    throw new Error('Invalid prompt response');
                }

                // ç”Ÿæˆå›¾ç‰‡
                const selectedModel = document.getElementById('imageModelSelect')?.value || 'black-forest-labs/flux-schnell';
                const imageResponse = await fetch('/generate-image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: promptData.prompt,
                        sectionId: 'story',
                        model: selectedModel
                    })
                });
                
                if (!imageResponse.ok) {
                    throw new Error(`Image generation failed: ${imageResponse.status}`);
                }
                
                const imageData = await imageResponse.json();
                console.log('Image generation response:', imageData);

                if (!imageData.success || !imageData.imageUrl) {
                    throw new Error('No image URL in response');
                }

                // ç¡®ä¿ imageUrl æ˜¯å­—ç¬¦ä¸²
                if (typeof imageData.imageUrl !== 'string') {
                    throw new Error('Invalid image URL format');
                }

                // è®¾ç½®å›¾ç‰‡
                imgContainer.onload = () => {
                    console.log('Image loaded successfully');
                    imgContainer.style.display = 'block';
                };
                
                imgContainer.onerror = (e) => {
                    console.error('Image load error:', e);
                    throw new Error('Failed to load image');
                };

                imgContainer.src = imageData.imageUrl;
                imgContainer.alt = 'Generated story image';
                
            } catch (error) {
                console.error('Image generation error:', error);
                alert('ç”Ÿæˆå›¾åƒå¤±è´¥ï¼š' + error.message);
                imgContainer.style.display = 'none';
            } finally {
                btn.disabled = false;
                btn.textContent = 'ç”Ÿæˆå›¾ç‰‡';
            }
        }

        // æ·»åŠ æ‰¹é‡ä¸‹è½½åŠŸèƒ½
        async function downloadAllImages() {
            const sections = document.querySelectorAll('.script-section');
            const images = [];
            
            sections.forEach(section => {
                const img = section.querySelector('.image-preview img');
                const promptDiv = section.querySelector('.image-prompt');
                
                if (img && img.src && img.src.startsWith('http')) {
                    images.push({
                        url: img.src,
                        prompt: promptDiv.textContent || img.dataset.prompt || ''
                    });
                }
            });
            
            console.log('Images to download:', images); // æ·»åŠ æ—¥å¿—
            
            if (images.length === 0) {
                alert('æ²¡æœ‰å¯ä¸‹è½½çš„å›¾ç‰‡');
                return;
            }
            
            const theme = document.getElementById('themeInput').value.trim() || 'story';
            
            try {
                const response = await fetch('/download-images', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ images, theme })
                });
                
                const data = await response.json();
                if (data.success) {
                    alert(`æˆåŠŸä¸‹è½½äº† ${data.totalImages} å¼ å›¾ç‰‡åˆ°ï¼š\n${data.directory}\n\nå·²åˆ›å»º gallery.html æ–‡ä»¶ç”¨äºé¢„è§ˆã€‚`);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                console.error('Download error:', error);
                alert('ä¸‹è½½å›¾ç‰‡å¤±è´¥ï¼š' + error.message);
            }
        }

        // æ·»åŠ ç”Ÿæˆæ‰€æœ‰å›¾ç‰‡çš„å‡½æ•°
        async function generateAllImages() {
            const sections = Array.from(document.querySelectorAll('.script-section')).map(section => ({
                id: section.id,
                text: section.querySelector('.text-input').value
            }));

            if (sections.length === 0) {
                alert('æœªæ‰¾åˆ°è„šæœ¬éƒ¨åˆ†');
                return;
            }

            const btn = document.getElementById('generateAllImagesBtn');
            btn.disabled = true;
            btn.textContent = 'Generating...';

            // æ·»åŠ è¿›åº¦æ˜¾ç¤ºå®¹å™¨
            const progressContainer = document.createElement('div');
            progressContainer.className = 'generation-progress';
            progressContainer.innerHTML = `
                <div class="progress-text">Initializing...</div>
                <div class="progress-bar">
                    <div class="progress" style="width: 0%"></div>
                </div>
            `;
            btn.parentNode.insertBefore(progressContainer, btn.nextSibling);

            try {
                const selectedModel = document.getElementById('imageModelSelect')?.value || 'black-forest-labs/flux-schnell';
                const response = await fetch('/generate-all-images', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sections: sections,
                        model: selectedModel
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    const lines = decoder.decode(value).split('\n');
                    for (const line of lines) {
                        if (!line) continue;

                        const data = JSON.parse(line);
                        const progressText = progressContainer.querySelector('.progress-text');
                        const progressBar = progressContainer.querySelector('.progress');

                        switch (data.type) {
                            case 'status':
                                progressText.textContent = data.message;
                                break;
                            case 'prompt_progress':
                                progressText.textContent = `${data.message} - æ­£åœ¨ç”Ÿæˆæç¤ºè¯...`;
                                progressBar.style.width = `${(data.current / data.total) * 50}%`; // æç¤ºè¯ç”Ÿæˆå æ€»è¿›åº¦çš„50%
                                break;
                            case 'image_progress':
                                progressText.textContent = `${data.message} - æ­£åœ¨ç”Ÿæˆå›¾ç‰‡...`;
                                progressBar.style.width = `${50 + (data.current / data.total) * 50}%`; // å›¾ç‰‡ç”Ÿæˆå å50%
                                break;
                            case 'section_complete':
                                const section = document.getElementById(data.sectionId);
                                if (section) {
                                    const imageContainer = section.querySelector('.section-image-container');
                                    const preview = imageContainer.querySelector('.image-preview');
                                    const img = preview.querySelector('img');
                                    const promptDiv = imageContainer.querySelector('.image-prompt');
                                    const regenerateControls = preview.querySelector('.regenerate-controls');
                                    const regenerateBtn = preview.querySelector('.regenerate-btn');
                                    const regenerateModelSelect = preview.querySelector('.regenerate-model-select');
                                    const loading = imageContainer.querySelector('.image-loading');

                                    promptDiv.textContent = data.prompt;
                                    promptDiv.style.display = 'block';

                                    // æ”¹è¿›å›¾ç‰‡åŠ è½½é€»è¾‘
                                    loading.style.display = 'flex';

                                    // æ¸…é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
                                    const newImg = img.cloneNode(false);

                                    newImg.onload = () => {
                                        console.log('Image loaded successfully:', data.imageUrl);
                                        loading.style.display = 'none';
                                        newImg.style.display = 'block';
                                        regenerateControls.style.display = 'flex';

                                        // è®¾ç½®é‡æ–°ç”Ÿæˆæ¨¡å‹é€‰æ‹©å™¨çš„é»˜è®¤å€¼
                                        if (regenerateModelSelect) {
                                            regenerateModelSelect.value = 'black-forest-labs/flux-schnell';
                                        }
                                    };

                                    newImg.onerror = () => {
                                        console.error('Failed to load image:', data.imageUrl);
                                        loading.style.display = 'none';
                                        alert(`åŠ è½½ç¬¬ ${data.sectionId} éƒ¨åˆ†çš„å›¾ç‰‡å¤±è´¥`);
                                    };

                                    // è®¾ç½®æ–°å›¾ç‰‡çš„å±æ€§
                                    newImg.src = data.imageUrl;
                                    newImg.dataset.prompt = data.prompt;
                                    newImg.style.maxWidth = '100%';
                                    newImg.style.display = 'none';

                                    // æ›¿æ¢æ—§å›¾ç‰‡
                                    img.parentNode.replaceChild(newImg, img);

                                    regenerateBtn.onclick = () => generateSectionImage(section, section.querySelector('.text-input').value, true);
                                }
                                break;
                            case 'complete':
                                progressText.textContent = 'æ‰€æœ‰å›¾ç‰‡ç”ŸæˆæˆåŠŸï¼';
                                progressBar.style.width = '100%';
                                setTimeout(() => {
                                    progressContainer.remove();
                                }, 3000);
                                break;
                            case 'error':
                                throw new Error(data.error);
                        }
                    }
                }
            } catch (error) {
                alert('ç”Ÿæˆå›¾ç‰‡å¤±è´¥ï¼š' + error.message);
                progressContainer.remove();
            } finally {
                btn.disabled = false;
                btn.textContent = 'ç”Ÿæˆæ‰€æœ‰å›¾ç‰‡';
            }
        }

        // æ·»åŠ æ–°çš„å‡½æ•°æ¥å¤„ç†æ·»åŠ è„šæœ¬æ®µè½
        function addScriptSection(type) {
            const scriptSections = document.getElementById('scriptSections');
            const scene = {
                type: type,
                text: '',
                character: type === 'dialogue' ? 'è§’è‰²åç§°' : undefined
            };
            
            // åœ¨æ§åˆ¶æŒ‰é’®ä¹‹å‰æ’å…¥æ–°æ®µè½
            const controls = scriptSections.querySelector('.script-controls');
            const section = createScriptSection(scene, Date.now());
            scriptSections.insertBefore(section, controls);
        }

        // æ·»åŠ ä¸‹è½½è„šæœ¬çš„å‡½æ•°
        async function downloadScript(format = 'json') {
            const scriptSections = document.getElementById('scriptSections');
            const sections = Array.from(scriptSections.querySelectorAll('.script-section'));
            
            if (format === 'json') {
                // JSON æ ¼å¼ä¸‹è½½ (ä¿æŒä¸å˜)
                const scriptData = {
                    scenes: sections.map(section => {
                        const type = section.querySelector('.section-type').textContent.toLowerCase();
                        const text = section.querySelector('.text-input').value;
                        const characterLabel = section.querySelector('.character-label');
                        
                        return {
                            type: type,
                            text: text,
                            ...(characterLabel && { character: characterLabel.textContent })
                        };
                    })
                };

                const blob = new Blob([JSON.stringify(scriptData, null, 2)], { type: 'application/json' });
                downloadFile(blob, `script-${new Date().toISOString().replace(/[:.]/g, '-')}.json`);
            } else if (format === 'txt') {
                // TXT æ ¼å¼ä¸‹è½½ (æ·»åŠ ç¿»è¯‘åŠŸèƒ½)
                try {
                    // å‡†å¤‡è‹±æ–‡å†…å®¹
                    const englishContent = sections.map(section => {
                        const type = section.querySelector('.section-type').textContent;
                        const text = section.querySelector('.text-input').value;
                        const characterLabel = section.querySelector('.character-label');
                        
                        if (characterLabel) {
                            return `[${type}]\n${characterLabel.textContent}:\n${text}`;
                        } else {
                            return `[${type}]\n${text}`;
                        }
                    }).join('\n\n');

                    // å‘é€ç¿»è¯‘è¯·æ±‚
                    const response = await fetch('/translate-story-script', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ script: englishContent })
                    });

                    const data = await response.json();
                    if (!data.success) {
                        throw new Error(data.error);
                    }

                    // åˆå¹¶è‹±æ–‡å’Œä¸­æ–‡å†…å®¹
                    const downloadContent = englishContent + '\n\n=== ä¸­æ–‡ç¿»è¯‘ ===\n\n' + data.translation;

                    // ä¸‹è½½åŒè¯­æ–‡ä»¶
                    const blob = new Blob([downloadContent], { type: 'text/plain' });
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    downloadFile(blob, `story-script-bilingual-${timestamp}.txt`);

                } catch (error) {
                    alert('ç¿»è¯‘å¤±è´¥ï¼š' + error.message);
                    
                    // å¦‚æœç¿»è¯‘å¤±è´¥ï¼Œä»ç„¶ä¸‹è½½è‹±æ–‡ç‰ˆæœ¬
                    const blob = new Blob([englishContent], { type: 'text/plain' });
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    downloadFile(blob, `story-script-${timestamp}.txt`);
                }
            }
        }

        // è¾…åŠ©å‡½æ•°ï¼šå¤„ç†æ–‡ä»¶ä¸‹è½½
        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // æ·»åŠ ç¿»è¯‘å’Œä¸‹è½½å‡½æ•°
        async function translateAndDownload() {
            const podcastSections = document.getElementById('podcastSections');
            if (!podcastSections || podcastSections.children.length === 0) {
                alert('è¯·å…ˆç”Ÿæˆæ’­å®¢è„šæœ¬');
                return;
            }

            const translateBtn = document.getElementById('translateBtn');
            translateBtn.disabled = true;
            translateBtn.textContent = 'æ­£åœ¨ç¿»è¯‘...';

            try {
                // æ”¶é›†æ‰€æœ‰å¯¹è¯å†…å®¹
                const dialogues = Array.from(podcastSections.querySelectorAll('.podcast-dialog')).map(dialog => {
                    const host = dialog.querySelector('.host-label').textContent;
                    const text = dialog.querySelector('textarea').value;
                    return `[${host}]\n${text}`;
                }).join('\n\n');

                // å‘é€ç¿»è¯‘è¯·æ±‚
                const response = await fetch('/translate-podcast', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ script: dialogues })
                });

                const data = await response.json();
                if (!data.success) {
                    throw new Error(data.error);
                }

                // å‡†å¤‡ä¸‹è½½å†…å®¹ï¼šåŸæ–‡å’Œè¯‘æ–‡å¹¶æ’æ˜¾ç¤º
                const downloadContent = dialogues + '\n\n=== ä¸­æ–‡ç¿»è¯‘ ===\n\n' + data.translation;

                // ä¸‹è½½æ–‡ä»¶
                const blob = new Blob([downloadContent], { type: 'text/plain' });
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                downloadFile(blob, `podcast-script-bilingual-${timestamp}.txt`);

            } catch (error) {
                alert('ç¿»è¯‘å¤±è´¥ï¼š' + error.message);
            } finally {
                translateBtn.disabled = false;
                translateBtn.textContent = 'ç¿»è¯‘å¹¶ä¸‹è½½';
            }
        }
    </script>
</body>
</html> 